-- ==================================================================
-- üöÄ SCRIPT DE SETUP COMPLETO - GOLDEN FORMUL√ÅRIO DE PEDIDOS
-- ==================================================================
-- Data: 02/02/2026
-- Descri√ß√£o: Cria TODAS as tabelas, √≠ndices e regras de uma vez s√≥.
-- INSTALA√á√ÉO: Copie e cole todo este conte√∫do no SQL Editor do Supabase.
-- ==================================================================



-- >>> IN√çCIO DO ARQUIVO: db_schema_users.sql <<<
-- CRIA√á√ÉO DA TABELA DE USU√ÅRIOS DO APLICATIVO
-- Execute este script no SQL Editor do Supabase

-- 1. Cria a tabela de usu√°rios
CREATE TABLE IF NOT EXISTS public.app_users (
    email text PRIMARY KEY,
    name text NOT NULL,
    role text DEFAULT 'user', -- 'admin' ou 'user'
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    last_login timestamp with time zone
);

-- 2. Habilita RLS (Seguran√ßa)
ALTER TABLE public.app_users ENABLE ROW LEVEL SECURITY;

-- 3. Cria pol√≠ticas de acesso (Simples para este caso de uso)

-- Permite leitura p√∫blica (para verificar login)
DROP POLICY IF EXISTS "Enable read access for all users" ON public.app_users;
CREATE POLICY "Enable read access for all users" ON public.app_users FOR SELECT USING (true);

-- Permite inser√ß√£o p√∫blica (para auto-cadastro)
DROP POLICY IF EXISTS "Enable insert access for all users" ON public.app_users;
CREATE POLICY "Enable insert access for all users" ON public.app_users FOR INSERT WITH CHECK (true);

-- Permite atualiza√ß√£o (para last_login)
DROP POLICY IF EXISTS "Enable update access for all users" ON public.app_users;
CREATE POLICY "Enable update access for all users" ON public.app_users FOR UPDATE USING (true);

-- 4. Insere o usu√°rio Admin inicial (Luciano)
INSERT INTO public.app_users (email, name, role)
VALUES ('luciano@goldenpr.com.br', 'Dr. Luciano Ferreira', 'admin')
ON CONFLICT (email) DO UPDATE 
SET role = 'admin'; -- Garante que Luciano seja admin

-- >>> FIM DO ARQUIVO: db_schema_users.sql <<<


-- >>> IN√çCIO DO ARQUIVO: db_schema_orders.sql <<<
-- TABELA DE PEDIDOS (Cria se n√£o existir)
create table if not exists public.orders (
  id text primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  date text,
  salesperson text,
  classification text,
  classification_other text,
  status text,
  customer_name text,
  customer_document text,
  customer_phone text,
  customer_email text,
  customer_birthday text,
  billing_address jsonb,
  collection_address jsonb,
  delivery_address jsonb,
  global_value_1 numeric,
  discount_total numeric,
  freight_value numeric,
  global_value_2 numeric,
  total_amount numeric,
  total_weight numeric,
  currency_conversion text,
  exchange_rate numeric,
  total_in_brl numeric,
  min_billing boolean,
  min_billing_value numeric,
  final_customer boolean,
  payment_terms text,
  delivery_time text,
  validity text,
  valid_until text,
  bidding_number text,
  bidding_date text,
  commitment_number text,
  commitment_date text,
  notes text,
  created_by text,          -- Email do usu√°rio criador
  pdf_url text,            -- URL do PDF gerado
  pdf_generated_at text    -- Data da gera√ß√£o do PDF
);

-- TABELA DE ITENS (Cria se n√£o existir)
create table if not exists public.order_items (
  id bigint generated by default as identity primary key,
  order_id text references public.orders(id) on delete cascade,
  code text,
  ncm text,
  description text,
  unit text,
  weight numeric,
  quantity numeric,
  unit_price numeric,
  total numeric
);

-- TABELA DE CONTATOS (Cria se n√£o existir)
create table if not exists public.order_contacts (
  id bigint generated by default as identity primary key,
  order_id text references public.orders(id) on delete cascade,
  name text,
  job_title text,
  department text,
  phone text,
  email text,
  birthday text
);

-- HABILITAR RLS (Seguran√ßa)
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.order_contacts enable row level security;

-- POL√çTICAS DE ACESSO (Drop e Recria para garantir)
drop policy if exists "Enable all for orders" on public.orders;
create policy "Enable all for orders" on public.orders for all using (true) with check (true);

drop policy if exists "Enable all for items" on public.order_items;
create policy "Enable all for items" on public.order_items for all using (true) with check (true);

drop policy if exists "Enable all for contacts" on public.order_contacts;
create policy "Enable all for contacts" on public.order_contacts for all using (true) with check (true);

-- >>> FIM DO ARQUIVO: db_schema_orders.sql <<<


-- >>> IN√çCIO DO ARQUIVO: db_schema_pdf_storage.sql <<<
-- SCRIPT PARA CONFIGURAR STORAGE DE PDFs NO SUPABASE
-- Execute este script no SQL Editor do Supabase DEPOIS de criar o bucket 'order-pdfs'

-- 1. Criar pol√≠tica de leitura p√∫blica (qualquer um pode baixar)
DROP POLICY IF EXISTS "Public Access" ON storage.objects;
CREATE POLICY "Public Access"
ON storage.objects FOR SELECT
USING ( bucket_id = 'order-pdfs' );

-- 2. Criar pol√≠tica de upload (apenas usu√°rios autenticados podem fazer upload)
-- Como estamos usando anon key, vamos permitir insert para todos
DROP POLICY IF EXISTS "Allow Upload" ON storage.objects;
CREATE POLICY "Allow Upload"
ON storage.objects FOR INSERT
WITH CHECK ( bucket_id = 'order-pdfs' );

-- 3. Criar pol√≠tica de delete (apenas admin pode deletar)
DROP POLICY IF EXISTS "Allow Delete" ON storage.objects;
CREATE POLICY "Allow Delete"
ON storage.objects FOR DELETE
USING ( bucket_id = 'order-pdfs' );

-- 4. Adicionar colunas na tabela orders para armazenar URLs dos PDFs
ALTER TABLE public.orders 
ADD COLUMN IF NOT EXISTS pdf_url text,
ADD COLUMN IF NOT EXISTS pdf_generated_at timestamp with time zone;

-- 5. Criar tabela para logs de PDFs de aceite
CREATE TABLE IF NOT EXISTS public.acceptance_pdfs (
  id bigint generated by default as identity primary key,
  order_id text references public.orders(id) on delete cascade,
  pdf_url text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  signer_name text,
  signer_email text
);

-- 6. Habilitar RLS
ALTER TABLE public.acceptance_pdfs ENABLE ROW LEVEL SECURITY;

-- 7. Pol√≠tica de acesso
DROP POLICY IF EXISTS "Enable all for acceptance_pdfs" ON public.acceptance_pdfs;
CREATE POLICY "Enable all for acceptance_pdfs" ON public.acceptance_pdfs 
FOR ALL USING (true) WITH CHECK (true);

-- >>> FIM DO ARQUIVO: db_schema_pdf_storage.sql <<<


-- >>> IN√çCIO DO ARQUIVO: db_optimization.sql <<<
-- =========================================
-- üöÄ DATABASE OPTIMIZATION SCRIPT
-- Formul√°rio de Pedidos Golden
-- =========================================
-- Descri√ß√£o: Adiciona √≠ndices para melhorar performance das queries
-- Executar em: Supabase SQL Editor
-- Data: 2026-02-02

-- =========================================
-- üìä √çNDICES PARA TABELA ORDERS
-- =========================================

-- √çndice para busca por usu√°rio criador (queries frequentes)
CREATE INDEX IF NOT EXISTS idx_orders_created_by 
ON public.orders(created_by);

-- √çndice para ordena√ß√£o por data de cria√ß√£o (listagem de pedidos)
CREATE INDEX IF NOT EXISTS idx_orders_created_at 
ON public.orders(created_at DESC);

-- √çndice para filtro por status (pedidos pendentes, aprovados, etc)
CREATE INDEX IF NOT EXISTS idx_orders_status 
ON public.orders(status);

-- √çndice para busca por nome do cliente
CREATE INDEX IF NOT EXISTS idx_orders_customer_name 
ON public.orders(customer_name);

-- √çndice para busca por documento do cliente (CPF/CNPJ)
CREATE INDEX IF NOT EXISTS idx_orders_customer_document 
ON public.orders(customer_document);

-- √çndice para busca por vendedor
CREATE INDEX IF NOT EXISTS idx_orders_salesperson 
ON public.orders(salesperson);

-- √çndice composto para queries complexas (usu√°rio + data)
CREATE INDEX IF NOT EXISTS idx_orders_created_by_date 
ON public.orders(created_by, created_at DESC);

-- =========================================
-- üì¶ √çNDICES PARA TABELA ORDER_ITEMS
-- =========================================

-- √çndice para JOIN com orders (FK)
CREATE INDEX IF NOT EXISTS idx_order_items_order_id 
ON public.order_items(order_id);

-- √çndice para busca por c√≥digo do produto
CREATE INDEX IF NOT EXISTS idx_order_items_code 
ON public.order_items(code);

-- =========================================
-- üë• √çNDICES PARA TABELA ORDER_CONTACTS
-- =========================================

-- √çndice para JOIN com orders (FK)
CREATE INDEX IF NOT EXISTS idx_order_contacts_order_id 
ON public.order_contacts(order_id);

-- √çndice para busca por email
CREATE INDEX IF NOT EXISTS idx_order_contacts_email 
ON public.order_contacts(email);

-- =========================================
-- üìÑ √çNDICES PARA TABELA ACCEPTANCE_PDFS
-- =========================================

-- √çndice para JOIN com orders (FK)
CREATE INDEX IF NOT EXISTS idx_acceptance_pdfs_order_id 
ON public.acceptance_pdfs(order_id);

-- √çndice para ordena√ß√£o por data
CREATE INDEX IF NOT EXISTS idx_acceptance_pdfs_created_at 
ON public.acceptance_pdfs(created_at DESC);

-- =========================================
-- üë§ √çNDICES PARA TABELA APP_USERS
-- =========================================

-- √çndice para busca por nome
CREATE INDEX IF NOT EXISTS idx_app_users_name 
ON public.app_users(name);

-- √çndice para filtro por role (admin vs user)
CREATE INDEX IF NOT EXISTS idx_app_users_role 
ON public.app_users(role);

-- =========================================
-- üìä AN√ÅLISE DE PERFORMANCE
-- =========================================

-- Atualizar estat√≠sticas das tabelas para o query planner
ANALYZE public.orders;
ANALYZE public.order_items;
ANALYZE public.order_contacts;
ANALYZE public.acceptance_pdfs;
ANALYZE public.app_users;

-- =========================================
-- ‚úÖ VERIFICA√á√ÉO
-- =========================================

-- Listar todos os √≠ndices criados
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename, indexname;

-- =========================================
-- üìù NOTAS
-- =========================================
-- 1. √çndices melhoram LEITURA mas podem lentificar ESCRITA
-- 2. Para este app (mais leitura que escrita), √≠ndices s√£o ben√©ficos
-- 3. Monitorar uso de √≠ndices com: pg_stat_user_indexes
-- 4. Remover √≠ndices n√£o utilizados se necess√°rio

-- =========================================
-- üéØ IMPACTO ESPERADO
-- =========================================
-- ‚úÖ Queries de listagem: 50-80% mais r√°pidas
-- ‚úÖ Buscas por cliente: 70-90% mais r√°pidas
-- ‚úÖ Filtros por status: 60-80% mais r√°pidas
-- ‚úÖ JOINs: 40-60% mais r√°pidos

-- >>> FIM DO ARQUIVO: db_optimization.sql <<<


-- >>> IN√çCIO DO ARQUIVO: db_audit.sql <<<
-- =========================================
-- üìù DATABASE AUDIT TRAIL SCRIPT
-- Formul√°rio de Pedidos Golden
-- =========================================
-- Descri√ß√£o: Adiciona campos de auditoria para rastreamento de mudan√ßas
-- Executar em: Supabase SQL Editor
-- Data: 2026-02-02

-- =========================================
-- üìä ADICIONAR CAMPOS DE AUDITORIA - ORDERS
-- =========================================

-- Adicionar campo de √∫ltima atualiza√ß√£o
ALTER TABLE public.orders 
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE;

-- Adicionar campo de quem atualizou
ALTER TABLE public.orders 
ADD COLUMN IF NOT EXISTS updated_by TEXT;

-- =========================================
-- üîß CRIAR FUN√á√ÉO DE AUTO-UPDATE
-- =========================================

-- Fun√ß√£o para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =========================================
-- ‚ö° CRIAR TRIGGER PARA ORDERS
-- =========================================

-- Remover trigger se j√° existir
DROP TRIGGER IF EXISTS update_orders_updated_at ON public.orders;

-- Criar trigger para atualizar updated_at em cada UPDATE
CREATE TRIGGER update_orders_updated_at 
BEFORE UPDATE ON public.orders 
FOR EACH ROW 
EXECUTE FUNCTION update_updated_at_column();

-- =========================================
-- üì¶ ADICIONAR AUDITORIA - ORDER_ITEMS
-- =========================================

ALTER TABLE public.order_items 
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE;

DROP TRIGGER IF EXISTS update_order_items_updated_at ON public.order_items;

CREATE TRIGGER update_order_items_updated_at 
BEFORE UPDATE ON public.order_items 
FOR EACH ROW 
EXECUTE FUNCTION update_updated_at_column();

-- =========================================
-- üë• ADICIONAR AUDITORIA - ORDER_CONTACTS
-- =========================================

ALTER TABLE public.order_contacts 
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE;

DROP TRIGGER IF EXISTS update_order_contacts_updated_at ON public.order_contacts;

CREATE TRIGGER update_order_contacts_updated_at 
BEFORE UPDATE ON public.order_contacts 
FOR EACH ROW 
EXECUTE FUNCTION update_updated_at_column();

-- =========================================
-- üë§ ADICIONAR AUDITORIA - APP_USERS
-- =========================================

ALTER TABLE public.app_users 
ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE;

DROP TRIGGER IF EXISTS update_app_users_updated_at ON public.app_users;

CREATE TRIGGER update_app_users_updated_at 
BEFORE UPDATE ON public.app_users 
FOR EACH ROW 
EXECUTE FUNCTION update_updated_at_column();

-- =========================================
-- üîç CRIAR VIEW DE AUDITORIA
-- =========================================

-- View para visualizar hist√≥rico de mudan√ßas
CREATE OR REPLACE VIEW public.orders_audit AS
SELECT 
    id,
    customer_name,
    created_at,
    created_by,
    updated_at,
    updated_by,
    CASE 
        WHEN updated_at IS NULL THEN 'Nunca atualizado'
        ELSE 'Atualizado em ' || updated_at::text
    END as status_auditoria,
    CASE 
        WHEN updated_at IS NOT NULL THEN 
            EXTRACT(EPOCH FROM (updated_at - created_at)) / 3600
        ELSE 0
    END as horas_ate_atualizacao
FROM public.orders
ORDER BY created_at DESC;

-- =========================================
-- üìä QUERY DE EXEMPLO - AUDITORIA
-- =========================================

-- Ver pedidos modificados nas √∫ltimas 24 horas
-- SELECT * FROM public.orders 
-- WHERE updated_at > NOW() - INTERVAL '24 hours'
-- ORDER BY updated_at DESC;

-- Ver quem mais modifica pedidos
-- SELECT 
--     updated_by,
--     COUNT(*) as total_modificacoes
-- FROM public.orders
-- WHERE updated_at IS NOT NULL
-- GROUP BY updated_by
-- ORDER BY total_modificacoes DESC;

-- =========================================
-- ‚úÖ VERIFICA√á√ÉO
-- =========================================

-- Verificar se campos foram adicionados
SELECT 
    table_name,
    column_name,
    data_type
FROM information_schema.columns
WHERE table_schema = 'public'
AND column_name IN ('updated_at', 'updated_by')
ORDER BY table_name, column_name;

-- Verificar se triggers foram criados
SELECT 
    trigger_name,
    event_object_table,
    action_statement
FROM information_schema.triggers
WHERE trigger_schema = 'public'
AND trigger_name LIKE '%updated_at%'
ORDER BY event_object_table;

-- =========================================
-- üìù NOTAS DE USO
-- =========================================
-- 1. updated_at √© preenchido AUTOMATICAMENTE pelo trigger
-- 2. updated_by deve ser preenchido pela aplica√ß√£o
-- 3. Exemplo de uso no c√≥digo:
--    await supabase
--      .from('orders')
--      .update({ 
--        ...data, 
--        updated_by: currentUserEmail 
--      })
--      .eq('id', orderId)

-- =========================================
-- üéØ BENEF√çCIOS
-- =========================================
-- ‚úÖ Rastreamento completo de mudan√ßas
-- ‚úÖ Auditoria de quem modificou o qu√™
-- ‚úÖ An√°lise de tempo de processamento
-- ‚úÖ Compliance e governan√ßa de dados

-- >>> FIM DO ARQUIVO: db_audit.sql <<<


-- >>> IN√çCIO DO ARQUIVO: db_soft_delete.sql <<<
-- =========================================
-- üóëÔ∏è SOFT DELETE IMPLEMENTATION
-- Formul√°rio de Pedidos Golden
-- =========================================
-- Descri√ß√£o: Implementa soft delete (n√£o deleta, apenas marca como deletado)
-- Executar em: Supabase SQL Editor
-- Data: 2026-02-02

-- =========================================
-- üìä ADICIONAR CAMPOS DE SOFT DELETE - ORDERS
-- =========================================

-- Adicionar campo de data de dele√ß√£o
ALTER TABLE public.orders 
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;

-- Adicionar campo de quem deletou
ALTER TABLE public.orders 
ADD COLUMN IF NOT EXISTS deleted_by TEXT;

-- =========================================
-- üì¶ ADICIONAR SOFT DELETE - ORDER_ITEMS
-- =========================================

ALTER TABLE public.order_items 
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;

ALTER TABLE public.order_items 
ADD COLUMN IF NOT EXISTS deleted_by TEXT;

-- =========================================
-- üë• ADICIONAR SOFT DELETE - ORDER_CONTACTS
-- =========================================

ALTER TABLE public.order_contacts 
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;

ALTER TABLE public.order_contacts 
ADD COLUMN IF NOT EXISTS deleted_by TEXT;

-- =========================================
-- üìÑ ADICIONAR SOFT DELETE - ACCEPTANCE_PDFS
-- =========================================

ALTER TABLE public.acceptance_pdfs 
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;

ALTER TABLE public.acceptance_pdfs 
ADD COLUMN IF NOT EXISTS deleted_by TEXT;

-- =========================================
-- üë§ ADICIONAR SOFT DELETE - APP_USERS
-- =========================================

ALTER TABLE public.app_users 
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;

ALTER TABLE public.app_users 
ADD COLUMN IF NOT EXISTS deleted_by TEXT;

-- =========================================
-- üîê ATUALIZAR POL√çTICAS RLS - ORDERS
-- =========================================

-- Remover pol√≠tica antiga
DROP POLICY IF EXISTS "Enable all for orders" ON public.orders;
DROP POLICY IF EXISTS "Select orders (exclude deleted)" ON public.orders;

-- Criar nova pol√≠tica que IGNORA registros deletados
DROP POLICY IF EXISTS "Enable all for orders (exclude deleted)" ON public.orders;
CREATE POLICY "Enable all for orders (exclude deleted)" 
ON public.orders 
FOR ALL 
USING (deleted_at IS NULL) 
WITH CHECK (deleted_at IS NULL);

-- =========================================
-- üîê ATUALIZAR POL√çTICAS RLS - ORDER_ITEMS
-- =========================================

DROP POLICY IF EXISTS "Enable all for items" ON public.order_items;
DROP POLICY IF EXISTS "Select items (exclude deleted)" ON public.order_items;

DROP POLICY IF EXISTS "Enable all for items (exclude deleted)" ON public.order_items;
CREATE POLICY "Enable all for items (exclude deleted)" 
ON public.order_items 
FOR ALL 
USING (deleted_at IS NULL) 
WITH CHECK (deleted_at IS NULL);

-- =========================================
-- üîê ATUALIZAR POL√çTICAS RLS - ORDER_CONTACTS
-- =========================================

DROP POLICY IF EXISTS "Enable all for contacts" ON public.order_contacts;
DROP POLICY IF EXISTS "Select contacts (exclude deleted)" ON public.order_contacts;

DROP POLICY IF EXISTS "Enable all for contacts (exclude deleted)" ON public.order_contacts;
CREATE POLICY "Enable all for contacts (exclude deleted)" 
ON public.order_contacts 
FOR ALL 
USING (deleted_at IS NULL) 
WITH CHECK (deleted_at IS NULL);

-- =========================================
-- üîê ATUALIZAR POL√çTICAS RLS - ACCEPTANCE_PDFS
-- =========================================

DROP POLICY IF EXISTS "Enable all for acceptance_pdfs" ON public.acceptance_pdfs;

DROP POLICY IF EXISTS "Enable all for acceptance_pdfs (exclude deleted)" ON public.acceptance_pdfs;
CREATE POLICY "Enable all for acceptance_pdfs (exclude deleted)" 
ON public.acceptance_pdfs 
FOR ALL 
USING (deleted_at IS NULL) 
WITH CHECK (deleted_at IS NULL);

-- =========================================
-- üîê ATUALIZAR POL√çTICAS RLS - APP_USERS
-- =========================================

DROP POLICY IF EXISTS "Enable all for app_users" ON public.app_users;

DROP POLICY IF EXISTS "Enable all for app_users (exclude deleted)" ON public.app_users;
CREATE POLICY "Enable all for app_users (exclude deleted)" 
ON public.app_users 
FOR ALL 
USING (deleted_at IS NULL) 
WITH CHECK (deleted_at IS NULL);

-- =========================================
-- üîç CRIAR VIEWS PARA DADOS DELETADOS
-- =========================================

-- View para ver apenas pedidos deletados
CREATE OR REPLACE VIEW public.orders_deleted AS
SELECT 
    id,
    customer_name,
    created_at,
    created_by,
    deleted_at,
    deleted_by,
    EXTRACT(EPOCH FROM (deleted_at - created_at)) / 86400 as dias_ate_delecao
FROM public.orders
WHERE deleted_at IS NOT NULL
ORDER BY deleted_at DESC;

-- View para ver todos os pedidos (incluindo deletados)
CREATE OR REPLACE VIEW public.orders_all AS
SELECT 
    id,
    customer_name,
    created_at,
    created_by,
    deleted_at,
    deleted_by,
    CASE 
        WHEN deleted_at IS NULL THEN 'Ativo'
        ELSE 'Deletado'
    END as status
FROM public.orders
ORDER BY created_at DESC;

-- =========================================
-- üîß FUN√á√ÉO PARA SOFT DELETE
-- =========================================

-- Fun√ß√£o helper para soft delete
CREATE OR REPLACE FUNCTION soft_delete_order(
    order_id TEXT,
    deleted_by_email TEXT
)
RETURNS VOID AS $$
BEGIN
    -- Marcar pedido como deletado
    UPDATE public.orders
    SET 
        deleted_at = NOW(),
        deleted_by = deleted_by_email
    WHERE id = order_id;
    
    -- Marcar itens como deletados
    UPDATE public.order_items
    SET 
        deleted_at = NOW(),
        deleted_by = deleted_by_email
    WHERE order_id = order_id;
    
    -- Marcar contatos como deletados
    UPDATE public.order_contacts
    SET 
        deleted_at = NOW(),
        deleted_by = deleted_by_email
    WHERE order_id = order_id;
    
    -- Marcar PDFs como deletados
    UPDATE public.acceptance_pdfs
    SET 
        deleted_at = NOW(),
        deleted_by = deleted_by_email
    WHERE order_id = order_id;
END;
$$ LANGUAGE plpgsql;

-- =========================================
-- üîß FUN√á√ÉO PARA RESTAURAR (UNDELETE)
-- =========================================

-- Fun√ß√£o para restaurar pedido deletado
CREATE OR REPLACE FUNCTION restore_order(
    order_id TEXT
)
RETURNS VOID AS $$
BEGIN
    -- Restaurar pedido
    UPDATE public.orders
    SET 
        deleted_at = NULL,
        deleted_by = NULL
    WHERE id = order_id;
    
    -- Restaurar itens
    UPDATE public.order_items
    SET 
        deleted_at = NULL,
        deleted_by = NULL
    WHERE order_id = order_id;
    
    -- Restaurar contatos
    UPDATE public.order_contacts
    SET 
        deleted_at = NULL,
        deleted_by = NULL
    WHERE order_id = order_id;
    
    -- Restaurar PDFs
    UPDATE public.acceptance_pdfs
    SET 
        deleted_at = NULL,
        deleted_by = NULL
    WHERE order_id = order_id;
END;
$$ LANGUAGE plpgsql;

-- =========================================
-- üîß FUN√á√ÉO PARA HARD DELETE (PERMANENTE)
-- =========================================

-- Fun√ß√£o para deletar permanentemente (usar com cuidado!)
CREATE OR REPLACE FUNCTION hard_delete_order(
    order_id TEXT
)
RETURNS VOID AS $$
BEGIN
    -- Deletar PDFs
    DELETE FROM public.acceptance_pdfs WHERE order_id = order_id;
    
    -- Deletar contatos
    DELETE FROM public.order_contacts WHERE order_id = order_id;
    
    -- Deletar itens
    DELETE FROM public.order_items WHERE order_id = order_id;
    
    -- Deletar pedido
    DELETE FROM public.orders WHERE id = order_id;
END;
$$ LANGUAGE plpgsql;

-- =========================================
-- üìä QUERIES DE EXEMPLO
-- =========================================

-- Soft delete de um pedido
-- SELECT soft_delete_order('ORDER_ID_AQUI', 'usuario@email.com');

-- Restaurar um pedido
-- SELECT restore_order('ORDER_ID_AQUI');

-- Ver pedidos deletados
-- SELECT * FROM public.orders_deleted;

-- Ver todos os pedidos (ativos + deletados)
-- SELECT * FROM public.orders_all;

-- Hard delete (CUIDADO! Permanente!)
-- SELECT hard_delete_order('ORDER_ID_AQUI');

-- =========================================
-- ‚úÖ VERIFICA√á√ÉO
-- =========================================

-- Verificar se campos foram adicionados
SELECT 
    table_name,
    column_name,
    data_type
FROM information_schema.columns
WHERE table_schema = 'public'
AND column_name IN ('deleted_at', 'deleted_by')
ORDER BY table_name, column_name;

-- Verificar pol√≠ticas RLS
SELECT 
    schemaname,
    tablename,
    policyname,
    permissive,
    roles,
    cmd,
    qual
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename;

-- =========================================
-- üìù NOTAS DE USO NO C√ìDIGO
-- =========================================
-- 1. Para deletar (soft delete):
--    await supabase.rpc('soft_delete_order', {
--      order_id: orderId,
--      deleted_by_email: currentUserEmail
--    })
--
-- 2. Para restaurar:
--    await supabase.rpc('restore_order', {
--      order_id: orderId
--    })
--
-- 3. Queries normais automaticamente ignoram deletados
--    (gra√ßas √†s pol√≠ticas RLS)

-- =========================================
-- üéØ BENEF√çCIOS
-- =========================================
-- ‚úÖ Dados nunca s√£o perdidos permanentemente
-- ‚úÖ Possibilidade de restaurar pedidos deletados
-- ‚úÖ Auditoria completa de dele√ß√µes
-- ‚úÖ Compliance com LGPD/GDPR (rastreamento)
-- ‚úÖ Prote√ß√£o contra dele√ß√µes acidentais

-- >>> FIM DO ARQUIVO: db_soft_delete.sql <<<


-- >>> IN√çCIO DO ARQUIVO: db_security.sql <<<
-- =========================================
-- üîê DATABASE SECURITY ENHANCEMENTS
-- Formul√°rio de Pedidos Golden
-- =========================================
-- Descri√ß√£o: Melhorias de seguran√ßa e valida√ß√£o de dados
-- Executar em: Supabase SQL Editor
-- Data: 2026-02-02

-- =========================================
-- ‚úÖ CONSTRAINTS DE VALIDA√á√ÉO - ORDERS
-- =========================================

-- Validar email do cliente
ALTER TABLE public.orders 
DROP CONSTRAINT IF EXISTS valid_customer_email;

ALTER TABLE public.orders 
ADD CONSTRAINT valid_customer_email 
CHECK (
    customer_email IS NULL OR
    customer_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
);

-- Validar valores num√©ricos positivos
ALTER TABLE public.orders 
DROP CONSTRAINT IF EXISTS positive_total_amount;

ALTER TABLE public.orders 
ADD CONSTRAINT positive_total_amount 
CHECK (total_amount IS NULL OR total_amount >= 0);

ALTER TABLE public.orders 
DROP CONSTRAINT IF EXISTS positive_freight_value;

ALTER TABLE public.orders 
ADD CONSTRAINT positive_freight_value 
CHECK (freight_value IS NULL OR freight_value >= 0);

ALTER TABLE public.orders 
DROP CONSTRAINT IF EXISTS positive_discount_total;

ALTER TABLE public.orders 
ADD CONSTRAINT positive_discount_total 
CHECK (discount_total IS NULL OR discount_total >= 0);

-- Validar status (apenas valores permitidos)
ALTER TABLE public.orders 
DROP CONSTRAINT IF EXISTS valid_status;

ALTER TABLE public.orders 
ADD CONSTRAINT valid_status 
CHECK (
    status IS NULL OR
    status IN ('Rascunho', 'Pendente', 'Aprovado', 'Rejeitado', 'Cancelado', 'Finalizado')
);

-- =========================================
-- ‚úÖ CONSTRAINTS DE VALIDA√á√ÉO - ORDER_ITEMS
-- =========================================

-- Quantidade deve ser positiva
ALTER TABLE public.order_items 
DROP CONSTRAINT IF EXISTS positive_quantity;

ALTER TABLE public.order_items 
ADD CONSTRAINT positive_quantity 
CHECK (quantity IS NULL OR quantity > 0);

-- Pre√ßo unit√°rio n√£o pode ser negativo
ALTER TABLE public.order_items 
DROP CONSTRAINT IF EXISTS non_negative_unit_price;

ALTER TABLE public.order_items 
ADD CONSTRAINT non_negative_unit_price 
CHECK (unit_price IS NULL OR unit_price >= 0);

-- Total n√£o pode ser negativo
ALTER TABLE public.order_items 
DROP CONSTRAINT IF EXISTS non_negative_total;

ALTER TABLE public.order_items 
ADD CONSTRAINT non_negative_total 
CHECK (total IS NULL OR total >= 0);

-- Peso n√£o pode ser negativo
ALTER TABLE public.order_items 
DROP CONSTRAINT IF EXISTS non_negative_weight;

ALTER TABLE public.order_items 
ADD CONSTRAINT non_negative_weight 
CHECK (weight IS NULL OR weight >= 0);

-- =========================================
-- ‚úÖ CONSTRAINTS DE VALIDA√á√ÉO - ORDER_CONTACTS
-- =========================================

-- Validar email do contato
ALTER TABLE public.order_contacts 
DROP CONSTRAINT IF EXISTS valid_contact_email;

ALTER TABLE public.order_contacts 
ADD CONSTRAINT valid_contact_email 
CHECK (
    email IS NULL OR
    email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
);

-- =========================================
-- ‚úÖ CONSTRAINTS DE VALIDA√á√ÉO - APP_USERS
-- =========================================

-- Email √© obrigat√≥rio e v√°lido
ALTER TABLE public.app_users 
DROP CONSTRAINT IF EXISTS valid_user_email;

ALTER TABLE public.app_users 
ADD CONSTRAINT valid_user_email 
CHECK (
    email IS NOT NULL AND
    email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
);

-- Nome √© obrigat√≥rio
ALTER TABLE public.app_users 
DROP CONSTRAINT IF EXISTS required_user_name;

ALTER TABLE public.app_users 
ADD CONSTRAINT required_user_name 
CHECK (name IS NOT NULL AND LENGTH(TRIM(name)) > 0);

-- =========================================
-- üîê POL√çTICAS RLS MELHORADAS - ORDERS
-- =========================================

-- Remover pol√≠tica antiga
DROP POLICY IF EXISTS "Enable all for orders (exclude deleted)" ON public.orders;

-- Pol√≠tica para SELECT (todos podem ver pedidos n√£o deletados)
CREATE POLICY "Select orders (exclude deleted)" 
ON public.orders 
FOR SELECT 
USING (deleted_at IS NULL);

-- Pol√≠tica para INSERT (qualquer usu√°rio autenticado pode criar)
CREATE POLICY "Insert orders" 
ON public.orders 
FOR INSERT 
WITH CHECK (true);

-- Pol√≠tica para UPDATE (apenas criador ou admin pode atualizar)
-- NOTA: Para implementar isso, precisaria de Supabase Auth
-- Por enquanto, permitindo todos
CREATE POLICY "Update orders" 
ON public.orders 
FOR UPDATE 
USING (deleted_at IS NULL)
WITH CHECK (deleted_at IS NULL);

-- Pol√≠tica para DELETE (apenas criador ou admin)
-- NOTA: Com soft delete, isso raramente ser√° usado
CREATE POLICY "Delete orders" 
ON public.orders 
FOR DELETE 
USING (deleted_at IS NULL);

-- =========================================
-- üîê POL√çTICAS RLS MELHORADAS - ORDER_ITEMS
-- =========================================

DROP POLICY IF EXISTS "Enable all for items (exclude deleted)" ON public.order_items;

CREATE POLICY "Select order_items" 
ON public.order_items 
FOR SELECT 
USING (deleted_at IS NULL);

CREATE POLICY "Insert order_items" 
ON public.order_items 
FOR INSERT 
WITH CHECK (true);

CREATE POLICY "Update order_items" 
ON public.order_items 
FOR UPDATE 
USING (deleted_at IS NULL)
WITH CHECK (deleted_at IS NULL);

CREATE POLICY "Delete order_items" 
ON public.order_items 
FOR DELETE 
USING (deleted_at IS NULL);

-- =========================================
-- üîê POL√çTICAS RLS MELHORADAS - ORDER_CONTACTS
-- =========================================

DROP POLICY IF EXISTS "Enable all for contacts (exclude deleted)" ON public.order_contacts;

CREATE POLICY "Select order_contacts" 
ON public.order_contacts 
FOR SELECT 
USING (deleted_at IS NULL);

CREATE POLICY "Insert order_contacts" 
ON public.order_contacts 
FOR INSERT 
WITH CHECK (true);

CREATE POLICY "Update order_contacts" 
ON public.order_contacts 
FOR UPDATE 
USING (deleted_at IS NULL)
WITH CHECK (deleted_at IS NULL);

CREATE POLICY "Delete order_contacts" 
ON public.order_contacts 
FOR DELETE 
USING (deleted_at IS NULL);

-- =========================================
-- üîê POL√çTICAS RLS MELHORADAS - ACCEPTANCE_PDFS
-- =========================================

DROP POLICY IF EXISTS "Enable all for acceptance_pdfs (exclude deleted)" ON public.acceptance_pdfs;

CREATE POLICY "Select acceptance_pdfs" 
ON public.acceptance_pdfs 
FOR SELECT 
USING (deleted_at IS NULL);

CREATE POLICY "Insert acceptance_pdfs" 
ON public.acceptance_pdfs 
FOR INSERT 
WITH CHECK (true);

CREATE POLICY "Update acceptance_pdfs" 
ON public.acceptance_pdfs 
FOR UPDATE 
USING (deleted_at IS NULL)
WITH CHECK (deleted_at IS NULL);

CREATE POLICY "Delete acceptance_pdfs" 
ON public.acceptance_pdfs 
FOR DELETE 
USING (deleted_at IS NULL);

-- =========================================
-- üîê POL√çTICAS RLS MELHORADAS - APP_USERS
-- =========================================

DROP POLICY IF EXISTS "Enable all for app_users (exclude deleted)" ON public.app_users;

CREATE POLICY "Select app_users" 
ON public.app_users 
FOR SELECT 
USING (deleted_at IS NULL);

CREATE POLICY "Insert app_users" 
ON public.app_users 
FOR INSERT 
WITH CHECK (true);

CREATE POLICY "Update app_users" 
ON public.app_users 
FOR UPDATE 
USING (deleted_at IS NULL)
WITH CHECK (deleted_at IS NULL);

CREATE POLICY "Delete app_users" 
ON public.app_users 
FOR DELETE 
USING (deleted_at IS NULL);

-- =========================================
-- üîç FUN√á√ÉO DE VALIDA√á√ÉO DE DADOS
-- =========================================

-- Fun√ß√£o para validar pedido antes de salvar
CREATE OR REPLACE FUNCTION validate_order()
RETURNS TRIGGER AS $$
BEGIN
    -- Validar que created_by est√° preenchido
    IF NEW.created_by IS NULL OR LENGTH(TRIM(NEW.created_by)) = 0 THEN
        RAISE EXCEPTION 'created_by √© obrigat√≥rio';
    END IF;
    
    -- Validar que customer_name est√° preenchido
    IF NEW.customer_name IS NULL OR LENGTH(TRIM(NEW.customer_name)) = 0 THEN
        RAISE EXCEPTION 'Nome do cliente √© obrigat√≥rio';
    END IF;
    
    -- Validar que total_amount √© consistente
    IF NEW.total_amount IS NOT NULL AND NEW.total_amount < 0 THEN
        RAISE EXCEPTION 'Valor total n√£o pode ser negativo';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Criar trigger de valida√ß√£o
DROP TRIGGER IF EXISTS validate_order_before_insert ON public.orders;
CREATE TRIGGER validate_order_before_insert
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW
EXECUTE FUNCTION validate_order();

-- =========================================
-- üìä VIEW DE SEGURAN√áA - DADOS SENS√çVEIS
-- =========================================

-- View que oculta dados sens√≠veis (para relat√≥rios p√∫blicos)
CREATE OR REPLACE VIEW public.orders_public AS
SELECT 
    id,
    date,
    salesperson,
    classification,
    status,
    -- Ocultar nome completo do cliente
    SUBSTRING(customer_name, 1, 3) || '***' as customer_name_masked,
    -- Ocultar documento
    '***' as customer_document_masked,
    -- Ocultar telefone
    '***' as customer_phone_masked,
    -- Ocultar email
    SUBSTRING(customer_email, 1, 3) || '***@***' as customer_email_masked,
    total_amount,
    created_at,
    created_by
FROM public.orders
WHERE deleted_at IS NULL;

-- =========================================
-- ‚úÖ VERIFICA√á√ÉO
-- =========================================

-- Listar todas as constraints
SELECT 
    conname as constraint_name,
    conrelid::regclass as table_name,
    pg_get_constraintdef(oid) as definition
FROM pg_constraint
WHERE connamespace = 'public'::regnamespace
AND contype = 'c'  -- Check constraints
ORDER BY conrelid::regclass::text, conname;

-- Listar todas as pol√≠ticas RLS
SELECT 
    schemaname,
    tablename,
    policyname,
    permissive,
    cmd as operation,
    qual as using_expression
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- =========================================
-- üìù NOTAS DE SEGURAN√áA
-- =========================================
-- 1. Constraints validam dados no n√≠vel do banco
-- 2. RLS protege acesso aos dados
-- 3. Triggers validam l√≥gica de neg√≥cio
-- 4. Views ocultam dados sens√≠veis
-- 5. Para seguran√ßa completa, implementar Supabase Auth

-- =========================================
-- üéØ PR√ìXIMOS PASSOS (RECOMENDADO)
-- =========================================
-- 1. Implementar Supabase Auth
-- 2. Atualizar pol√≠ticas RLS para usar auth.uid()
-- 3. Adicionar rate limiting
-- 4. Configurar backup autom√°tico
-- 5. Implementar logs de acesso

-- =========================================
-- üéØ BENEF√çCIOS
-- =========================================
-- ‚úÖ Valida√ß√£o de dados no banco
-- ‚úÖ Prote√ß√£o contra dados inv√°lidos
-- ‚úÖ Pol√≠ticas RLS granulares
-- ‚úÖ Auditoria de mudan√ßas
-- ‚úÖ Prote√ß√£o de dados sens√≠veis

-- >>> FIM DO ARQUIVO: db_security.sql <<<
